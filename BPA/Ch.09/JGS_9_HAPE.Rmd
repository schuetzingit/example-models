---
title: "JGS_9"
author: "Justin Schuetz"
date: "2022-10-31"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

```{r}

library(tidyverse)
library(brms)
library(rethinking)
library(tidybayes)
library(rjags)
library(jagsUI)
library(ggdist)
library(nimble)
library(MCMCvis)

```

## Define function to simulate data

```{r}

simulateHistoriesHAPE <- function(PSI_STATES, PSI_OBS, N, NOTSEEABLE = NA) { 
  
  # unobservable: the number of the unobservable state
  
  n.occasions <- dim(PSI_STATES)[4] + 1
  CH <- CH_TRUE <- matrix(NA, ncol = n.occasions, nrow = sum(N))
  
  # define a vector with the occasion of marking
  
  mark.occ <- matrix(0, ncol = dim(PSI_STATES)[1], nrow = sum(N))
  
  g <- colSums(N)
  
  for (s in 1:dim(PSI_STATES)[1]) {
    
    if (g[s] == 0) next # To avoid error message if nothing to replace
    mark.occ[(cumsum(g[1:s]) - g[s] + 1)[s]:cumsum(g[1:s])[s], s] <- rep(1:n.occasions, N[1:n.occasions, s])
      
  }
  
  for (i in 1:sum(N)) {
    
    for (s in 1:dim(PSI_STATES)[1]) {
      
      if (mark.occ[i, s] == 0) next 
      first <- mark.occ[i, s]
      CH[i, first] <- s
      CH_TRUE[i, first] <- s
      
    }
    
    for (t in (first+1):n.occasions) {
      
      if (first == n.occasions) next
      
      # Multinomial trials for state transitions
      state <- which(rmultinom(1, 1, PSI_STATES[CH_TRUE[i, t-1], , i, t-1]) == 1)
      CH_TRUE[i, t] <- state
      
      # Multinomial trials for observation process
      event <- which(rmultinom(1, 1, PSI_OBS[CH_TRUE[i, t], , i, t-1]) == 1)
      CH[i, t] <- event
      
      }
    
  }
    # Replace the NA and the highest state number (dead) in the file by 0
 
  CH[is.na(CH)] <- 0
  CH[CH == dim(PSI_STATES)[1]] <- 0
  CH[CH == NOTSEEABLE] <- 0
  id <- numeric(0)
  
  for (i in 1:dim(CH)[1]) {
    z <- min(which(CH[i, ] != 0))
    ifelse(z == dim(CH)[2], id <- c(id, i), id <- c(id))
    }
  
  # CH: capture histories to be used
   # CH.TRUE: capture histories with perfect observation
  
  return(list(ch = CH[-id, ],
            ch_true = CH_TRUE[-id,]))
  
}


```

## Define function to identify fist capture occasion

```{r}

idFirstCaptureHAPE <- function(CH) {
  
  f <- apply(CH, MARGIN = 1, FUN = function(x) min(which(x != 0)))
  
  return(f)
  
}

```

## Define function to create known latent states z

```{r}

idKnownStatesHAPE <- function(CH, NOTSEEN){
   
  # NOTSEEN: label for ënot seení
  
  state <- CH
  state[state == NOTSEEN] <- NA
  
  for (i in 1:dim(CH)[1]){
      m <- min(which(!is.na(state[i, ])))
      state[i, m] <- NA
      }
  
  return(state)

}

```

## Define function to create initial values for unknown z

```{r}

createZInitsHAPE <- function(CH, F) {
  
  CH[CH == 3] <- NA # set state at unobserved indices to NA
   
  v2 <- which(CH == 2, arr.ind = T) # get array indices for dead recoveries
   
  CH[v2] <- 2 # set state at index of dead recovery to dead
   
  # if dead recovery isn't in the last column set all following states to dead absorbing
   
  for (i in 1:nrow(v2)) { 
    ifelse(v2[i,2] != ncol(CH), CH[v2[i,1], (v2[i,2]+1):ncol(CH)] <- 3, next)
    }
   
  # fill in states between first and last live observation with alive in study area
   
  for (i in 1:nrow(CH)) {
    m <- max(which(CH[i,]==1))
    CH[i,F[i]:m] <- 1
    }
  
  for (i in 1:nrow(v2)) {
    u1 <- min(which(CH[v2[i,1],]==1))
    CH[v2[i], u1:(v2[i,2]-1)] <- 1
    }
  
  for (i in 1:nrow(CH)) {
    for (j in F[i]:ncol(CH)) {
      if(is.na(CH[i,j])==1) CH[i,j] <- 1
      }
    CH[i,F[i]] <- NA
    }
   
  return(CH)
  
  }


```

## Simulate data for mark-recapture-recovery HAPE

```{r}

# Joint analysis of capture-recapture and mark-recovery data

# Define mean survival, transitions, recapture, as well as number of occasions, states, observations and released individuals 
s <- 0.8
r <- 0.1
p <- 0.5

n.occasions <- 5  
n.states <- 3
n.obs <- 3
n <- matrix(0, ncol = n.states, nrow = n.occasions)

n[ , 1] <- rep(100, n.occasions)	# Releases in study area
#n[ , 1] <- c(100, 0, 0, 0, 0)	# Releases in study area

# Define matrices with survival, transition and recapture probabilities
# These are 4-dimensional matrices, with 
   # Dimension 1: state of departure
   # Dimension 2: state of arrival
   # Dimension 3: individual
   # Dimension 4: time


# 1. State process matrix
released <- sum(n) * (n.occasions-1)

PSI.STATE <- array(NA, dim=c(n.states, n.states, released, n.occasions-1))

for (i in 1:released){
   
  for (t in 1:(n.occasions-1)) {
      
    PSI.STATE[,,i,t] <- matrix(c(
      s[t],  (1-s[t])*r[t],  (1-s[t])*(1-r[t]),
      0,     0,       1,
      0,     0,       1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
   
  } #i

# 2.Observation process matrix

PSI.OBS <- array(NA, dim=c(n.states, n.obs, released, n.occasions-1))

for (i in 1:released) {
  
  for (t in 1:(n.occasions-1)) {
      
     PSI.OBS[,,i,t] <- matrix(c(
      p[t],   0,      1-p[t],
      0,      1,      0,
      0,      0,      1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
  
  } #i

```

# HAPE model

```{r}

sink("model.HAPE.jags")
cat("
model {

# -------------------------------------------------
# Parameters:
# s: true survival probability
# r: recovery probability
# p: detection probability
# -------------------------------------------------
# States (S):
# 1 alive in study area
# 2 recently dead (and recovered)
# 3 recently dead, but not recovered, or dead (absorbing)
# Observations (O):
# 1 seen alive
# 2 recovered dead
# 3 neither seen nor recovered
# -------------------------------------------------

# Priors and constraints
for (t in 1:(n.occasions-1)){
   s[t] <- mean.s
   p[t] <- mean.r 
   r[t] <- mean.p 
}

mean.s ~ dunif(0, 1)     # Prior for mean survival
mean.r ~ dunif(0, 1)     # Prior for mean recovery
mean.p ~ dunif(0, 1)     # Prior for mean recapture

# Define state-transition and observation matrices 	

for (i in 1:nind) {

   # Define probabilities of state S(t+1) given S(t)
   
   for (t in f[i]:(n.occasions-1)) {
      ps[1,i,t,1] <- s[t]
      ps[1,i,t,2] <- (1-s[t]) * r[t] 
      ps[1,i,t,3] <- (1-s[t]) * (1-r[t])
      ps[2,i,t,1] <- 0
      ps[2,i,t,2] <- 0
      ps[2,i,t,3] <- 1
      ps[3,i,t,1] <- 0
      ps[3,i,t,2] <- 0
      ps[3,i,t,3] <- 1

      # Define probabilities of O(t) given S(t)
      po[1,i,t,1] <- p[t]
      po[1,i,t,2] <- 0
      po[1,i,t,3] <- 1-p[t]
      po[2,i,t,1] <- 0
      po[2,i,t,2] <- 1
      po[2,i,t,3] <- 0
      po[3,i,t,1] <- 0
      po[3,i,t,2] <- 0
      po[3,i,t,3] <- 1
      
      } #t
      
   } #i

  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], i, t-1,])
      
    } #t
   
  } #i
}
", fill = TRUE)

sink()

```

## HAPE data prep

```{r}

# Execute simulation function
sim <- simulateHistoriesHAPE(PSI.STATE, PSI.OBS, n)

ch <- sim$ch

# Compute date of first capture
f <- idFirstCaptureHAPE(ch)

# Recode CH matrix: note, a 0 is not allowed!
# 1 = alive and in study are, 2 = recovered dead, 3 = not seen or recovered
rch <- ch  # Recoded CH
rch[rch == 0] <- 3


##### approach 2

z_known_jgs <- idKnownStatesHAPE(rch, 3)

x <- rch
x[x==3] <- NA

z_init_jgs <- createZInitsHAPE(rch, f)
z_init_jgs[!is.na(x)] <- NA


```

## HAPE analysis

```{r}

# Bundle data
jags.data <- list(y = rch, 
                  f = f, 
                  n.occasions = dim(rch)[2], 
                  nind = dim(rch)[1],
                  z = z_known_jgs)


inits <- function(){list(mean.s = runif(1, 0, 1), 
                         mean.r = runif(1, 0, 1), 
                         mean.p = runif(1, 0, 1),
                         z = z_init_jgs)}  


# Parameters monitored
parameters <- c("mean.s", "mean.r", "mean.p")


# MCMC settings
ni <- 15000
nt <- 3
nb <- 9000
nc <- 3


# Call JAGS from R (BRT 80 min)
lifedead <- jagsUI::jags(jags.data, 
                         inits, 
                         parameters, "model.HAPE.jags", 
                         n.chains = nc, 
                         n.thin = nt, 
                         n.iter = ni, 
                         n.burnin = nb,
                         parallel = T)


print(lifedead, digit = 3)


jagsUI::traceplot(lifedead)

```

## Simulate data for mark-recapture-recovery HAPE

```{r}

# Joint analysis of capture-recapture and mark-recovery data

# Define mean survival, transitions, recapture, as well as number of occasions, states, observations and released individuals 

s <- c(0.95, 0.85, 0.75, 0.85)
r <- c(0, 0, 0.2, 0.2)
p <- c(1, 0.8, 0.8, 1)

n.occasions <- 5  
n.states <- 3
n.obs <- 3
n <- matrix(0, ncol = n.states, nrow = n.occasions)

n[ , 1] <- rep(500, n.occasions)	# Releases in study area
#n[ , 1] <- c(100, 0, 0, 0, 0)	# Releases in study area

# Define matrices with survival, transition and recapture probabilities
# These are 4-dimensional matrices, with 
   # Dimension 1: state of departure
   # Dimension 2: state of arrival
   # Dimension 3: individual
   # Dimension 4: time


# 1. State process matrix
released <- sum(n) * (n.occasions-1)

PSI.STATE <- array(NA, dim=c(n.states, n.states, released, n.occasions-1))

for (i in 1:released){
   
  for (t in 1:(n.occasions-1)) {
      
    PSI.STATE[,,i,t] <- matrix(c(
      s[t],  (1-s[t])*r[t],  (1-s[t])*(1-r[t]),
      0,     0,       1,
      0,     0,       1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
   
  } #i

# 2.Observation process matrix

PSI.OBS <- array(NA, dim=c(n.states, n.obs, released, n.occasions-1))

for (i in 1:released) {
  
  for (t in 1:(n.occasions-1)) {
      
     PSI.OBS[,,i,t] <- matrix(c(
      p[t],   0,      1-p[t],
      0,      1,      0,
      0,      0,      1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
  } #i

```

# HAPE model

This works ok

```{r}

sink("model.HAPE.t.jags")
cat("
model {

# -------------------------------------------------
# Parameters:
# s: true survival probability
# r: recovery probability
# p: detection probability
# -------------------------------------------------
# States (S):
# 1 alive in study area
# 2 recently dead (and recovered)
# 3 recently dead, but not recovered, or dead (absorbing)
# Observations (O):
# 1 seen alive
# 2 recovered dead
# 3 neither seen nor recovered
# -------------------------------------------------

# Priors and constraints
for (t in 1:(n.occasions-1)){
   s[t] ~ dbeta(1, 1)
   p[t] ~ dbeta(1, 1)
   r[t] ~ dunif(0, 0.3)
}

# Define state-transition and observation matrices 	


   # Define probabilities of state S(t+1) given S(t)
   
   for (t in 1:(n.occasions-1)) {
      ps[1,t,1] <- s[t]
      ps[1,t,2] <- (1-s[t]) * r[t] 
      ps[1,t,3] <- (1-s[t]) * (1-r[t])
      ps[2,t,1] <- 0
      ps[2,t,2] <- 0
      ps[2,t,3] <- 1
      ps[3,t,1] <- 0
      ps[3,t,2] <- 0
      ps[3,t,3] <- 1

      # Define probabilities of O(t) given S(t)
      po[1,t,1] <- p[t]
      po[1,t,2] <- 0
      po[1,t,3] <- 1-p[t]
      po[2,t,1] <- 0
      po[2,t,2] <- 1
      po[2,t,3] <- 0
      po[3,t,1] <- 0
      po[3,t,2] <- 0
      po[3,t,3] <- 1
      
      } #t
      
  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], t-1,])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], t-1,])
      
    } #t
   
  } #i
}
", fill = TRUE)

sink()

```

# HAPE model 

not working

```{r}

sink("model.HAPE.t.alt.jags")
cat("
model {

# -------------------------------------------------
# Parameters:
# s: true survival probability
# r: recovery probability
# p: detection probability
# -------------------------------------------------
# States (S):
# 1 alive in study area
# 2 recently dead (and recovered)
# 3 recently dead, but not recovered, or dead (absorbing)
# Observations (O):
# 1 seen alive
# 2 recovered dead
# 3 neither seen nor recovered
# -------------------------------------------------

# Priors and constraints

for (t in 1:(n.occasions-1)){
   s[t] ~ dbeta(1, 1)
   p[t] ~ dbeta(1, 1)
}

for (t in 1:2){
   r[t] ~ dbeta(1, 1)
}



# Define state-transition and observation matrices 	

   # Define probabilities of state S(t+1) given S(t)
   
   for (t in 1:(n.occasions-1)) {
      
      ps[1,t,1] <- s[t]
      ps[2,t,1] <- 0
      ps[2,t,2] <- 0
      ps[2,t,3] <- 1
      ps[3,t,1] <- 0
      ps[3,t,2] <- 0
      ps[3,t,3] <- 1

      # Define probabilities of O(t) given S(t)

      po[1,t,1] <- p[t]
      po[1,t,2] <- 0
      po[1,t,3] <- 1-p[t] 
      po[2,t,1] <- 0
      po[2,t,2] <- 1
      po[2,t,3] <- 0
      po[3,t,1] <- 0
      po[3,t,2] <- 0
      po[3,t,3] <- 1
      
    } #t
      
    rfix <- 0
    
    for (t in 1:2) {
      
      ps[1,t,2] <- 1-s[t] * rfix
      ps[1,t,3] <- 1-s[t] * (1-rfix)
      
    }  
     
    for (t in 3:4) {
      
      ps[1,t,2] <- (1-s[t]) * r[t-2]
      ps[1,t,3] <- (1-s[t]) * (1-r[t-2])
      
    } 
  
  
  
  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], t-1,])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], t-1,])
      
    } #t
   
  } #i
}
", fill = TRUE)

sink()

```

# HAPE model

```{r}

sink("model.HAPE.t.alt2.jags")
cat("
model {

# -------------------------------------------------
# Parameters:
# s: true survival probability
# r: recovery probability
# p: detection probability
# -------------------------------------------------
# States (S):
# 1 alive in study area
# 2 recently dead (and recovered)
# 3 recently dead, but not recovered, or dead (absorbing)
# Observations (O):
# 1 seen alive
# 2 recovered dead
# 3 neither seen nor recovered
# -------------------------------------------------

# Priors and constraints

for (t in 1:(n.occasions-1)){
   
   s[t] ~ dbeta(1, 1)
   p[t] ~ dbeta(1, 1)
   r[t] ~ dbeta(1, 1)
   
   }



# Define state-transition and observation matrices 	

   # Define probabilities of state S(t+1) given S(t)
   
   for (t in 1:(n.occasions-1)) {
      
      ps[1,t,1] <- s[t]
      ps[1,t,2] <- 1-s[t]
      ps[1,t,3] <- 0
      ps[2,t,1] <- 0
      ps[2,t,2] <- 0
      ps[2,t,3] <- 1
      ps[3,t,1] <- 0
      ps[3,t,2] <- 0
      ps[3,t,3] <- 1

      # Define probabilities of O(t) given S(t)

      po[1,t,1] <- p[t]
      po[1,t,2] <- 0
      po[1,t,3] <- 1-p[t] 
      po[2,t,1] <- 0
      po[2,t,2] <- r[t]
      po[2,t,3] <- 1-r[t]
      po[3,t,1] <- 0
      po[3,t,2] <- 0
      po[3,t,3] <- 1
      
      } #t
      
   
  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], t-1,])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], t-1,])
      
      } #t
   
   } #i
   
}
", fill = TRUE)

sink()

```

## HAPE data prep

```{r}

# Execute simulation function
sim <- simulateHistoriesHAPE(PSI.STATE, PSI.OBS, n, NOTSEEABLE = 3)

ch <- sim$ch[1:500, ]

# Compute date of first capture
f <- idFirstCaptureHAPE(ch)

# Recode CH matrix: note, a 0 is not allowed!
# 1 = alive and in study are, 2 = recovered dead, 3 = not seen or recovered
rch <- ch  # Recoded CH
rch[rch == 0] <- 3


##### approach 2

z_known_jgs <- idKnownStatesHAPE(rch, 3)

x <- rch
x[x==3] <- NA

z_init_jgs <- createZInitsHAPE(rch, f)
z_init_jgs[!is.na(x)] <- NA


```

## HAPE analysis

```{r}

# Bundle data
jags.data <- list(y = rch, 
                  f = f, 
                  n.occasions = dim(rch)[2], 
                  nind = dim(rch)[1],
                  z = z_known_jgs)


inits <- function(){list(s = rbeta(4, 1, 1), 
                         r = rbeta(4, 1, 1), 
                         p = rbeta(4, 1, 1),
                         z = z_init_jgs)}  


# Parameters monitored
parameters <- c("s", "r", "p")


# MCMC settings
ni <- 50000
nt <- 10
nb <- 40000
nc <- 3


# Call JAGS from R (BRT 80 min)
lifedead.t <- jagsUI::jags(jags.data, 
                         inits, 
                         parameters, "model.HAPE.t.alt2.jags", 
                         n.chains = nc, 
                         n.thin = nt, 
                         n.iter = ni, 
                         n.burnin = nb,
                         parallel = T)


print(lifedead.t, digit = 3)


jagsUI::traceplot(lifedead.t)

```

## Simulate data for mark-recapture-recovery HAPE

```{r}

# Joint analysis of capture-recapture and mark-recovery data

# Define mean survival, transitions, recapture, as well as number of occasions, states, observations and released individuals 

s <- c(0.8, 0.6, 0.6, 0.7)
r <- c(0, 0, 0.2, 0.1)
p <- c(1, 0.8, 0.8, 1)

n.occasions <- 5  
n.states <- 3
n.obs <- 3
n <- matrix(0, ncol = n.states, nrow = n.occasions)

n[ , 1] <- rep(100, n.occasions)	# Releases in study area

# Define matrices with survival, transition and recapture probabilities
# These are 4-dimensional matrices, with 
   # Dimension 1: state of departure
   # Dimension 2: state of arrival
   # Dimension 3: individual
   # Dimension 4: time


# 1. State process matrix
released <- sum(n) * (n.occasions-1)

PSI.STATE <- array(NA, dim=c(n.states, n.states, released, n.occasions-1))

for (i in 1:released){
   
  for (t in 1:(n.occasions-1)) {
      
    PSI.STATE[,,i,t] <- matrix(c(
      s[t],  (1-s[t])*r[t],  (1-s[t])*(1-r[t]),
      0,     0,       1,
      0,     0,       1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
   
  } #i

# 2.Observation process matrix

PSI.OBS <- array(NA, dim=c(n.states, n.obs, released, n.occasions-1))

for (i in 1:released) {
  
  for (t in 1:(n.occasions-1)) {
      
     PSI.OBS[,,i,t] <- matrix(c(
      p[t],   0,      1-p[t],
      0,      1,      0,
      0,      0,      1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
  
  } #i


```

# HAPE model

```{r}

sink("model.HAPE.t.fixed.jags")
cat("
model {

# -------------------------------------------------
# Parameters:
# s: true survival probability
# r: recovery probability
# p: detection probability
# -------------------------------------------------
# States (S):
# 1 alive in study area
# 2 recently dead (and recovered)
# 3 recently dead, but not recovered, or dead (absorbing)
# Observations (O):
# 1 seen alive
# 2 recovered dead
# 3 neither seen nor recovered
# -------------------------------------------------

# Priors and constraints

p <- c(1, 0.5, 0.5, 1)

for (t in 1:(n.occasions-1)){
   s[t] ~ dunif(0, 1)
   r[t] ~ dunif(0, 1)
   #p[t] ~ dunif(pv[t], 1)
}

# Define state-transition and observation matrices 	

for (i in 1:nind) {

   # Define probabilities of state S(t+1) given S(t)
   
   for (t in f[i]:(n.occasions-1)) {
      ps[1,i,t,1] <- s[t]
      ps[1,i,t,2] <- (1-s[t]) * r[t] 
      ps[1,i,t,3] <- (1-s[t]) * (1-r[t])
      ps[2,i,t,1] <- 0
      ps[2,i,t,2] <- 0
      ps[2,i,t,3] <- 1
      ps[3,i,t,1] <- 0
      ps[3,i,t,2] <- 0
      ps[3,i,t,3] <- 1

      # Define probabilities of O(t) given S(t)
      po[1,i,t,1] <- p[t]
      po[1,i,t,2] <- 0
      po[1,i,t,3] <- 1-p[t]
      po[2,i,t,1] <- 0
      po[2,i,t,2] <- 1
      po[2,i,t,3] <- 0
      po[3,i,t,1] <- 0
      po[3,i,t,2] <- 0
      po[3,i,t,3] <- 1
      
      } #t
      
   } #i

  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], i, t-1,])
      
    } #t
   
  } #i
}
", fill = TRUE)

sink()

```

## HAPE data prep

```{r}

# Execute simulation function
sim <- simulateHistoriesHAPE(PSI.STATE, PSI.OBS, n)

ch <- sim$ch

# Compute date of first capture
f <- idFirstCaptureHAPE(ch)

# Recode CH matrix: note, a 0 is not allowed!
# 1 = alive and in study are, 2 = recovered dead, 3 = not seen or recovered
rch <- ch  # Recoded CH
rch[rch == 0] <- 3


##### approach 2

z_known_jgs <- idKnownStatesHAPE(rch, 3)

x <- rch
x[x==3] <- NA

z_init_jgs <- createZInitsHAPE(rch, f)
z_init_jgs[!is.na(x)] <- NA


```

## HAPE analysis

```{r}

# Bundle data
jags.data <- list(y = rch, 
                  f = f, 
                  n.occasions = dim(rch)[2], 
                  nind = dim(rch)[1],
                  z = z_known_jgs)


inits <- function(){list(s = dbeta(4, 1, 1), 
                         r = dbeta(4, 1, 1), 
                         p = dbeta(4, 1, 1),
                         z = z_init_jgs)}  


# Parameters monitored
parameters <- c("s", "r", "p")


# MCMC settings
ni <- 25000
nt <- 15
nb <- 10000
nc <- 3


# Call JAGS from R (BRT 80 min)
lifedead.t.fix <- jagsUI::jags(jags.data, 
                         inits, 
                         parameters, "model.HAPE.t.fixed.jags", 
                         n.chains = nc, 
                         n.thin = nt, 
                         n.iter = ni, 
                         n.burnin = nb,
                         parallel = T)


print(lifedead.t, digit = 3)


jagsUI::traceplot(lifedead.t)

```

## NIMBLE: Simulate data for mark-recapture-recovery HAPE

```{r}

# Joint analysis of capture-recapture and mark-recovery data

# Define mean survival, transitions, recapture, as well as number of occasions, states, observations and released individuals 

s <- c(0.95, 0.85, 0.75, 0.85)
r <- c(0, 0, 0.4, 0.2)
p <- c(1, 0.8, 0.8, 1)

n.occasions <- 5  
n.states <- 3
n.obs <- 3
n <- matrix(0, ncol = n.states, nrow = n.occasions)

n[ , 1] <- rep(500, n.occasions)	# Releases in study area
#n[ , 1] <- c(100, 0, 0, 0, 0)	# Releases in study area

# Define matrices with survival, transition and recapture probabilities
# These are 4-dimensional matrices, with 
   # Dimension 1: state of departure
   # Dimension 2: state of arrival
   # Dimension 3: individual
   # Dimension 4: time


# 1. State process matrix
released <- sum(n) * (n.occasions-1)

PSI.STATE <- array(NA, dim=c(n.states, n.states, released, n.occasions-1))

for (i in 1:released){
   
  for (t in 1:(n.occasions-1)) {
      
    PSI.STATE[,,i,t] <- matrix(c(
      s[t],  (1-s[t])*r[t],  (1-s[t])*(1-r[t]),
      0,     0,       1,
      0,     0,       1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
   
  } #i

# 2.Observation process matrix

PSI.OBS <- array(NA, dim=c(n.states, n.obs, released, n.occasions-1))

for (i in 1:released) {
  
  for (t in 1:(n.occasions-1)) {
      
     PSI.OBS[,,i,t] <- matrix(c(
      p[t],   0,      1-p[t],
      0,      1,      0,
      0,      0,      1), 
      nrow = n.states, byrow = TRUE)
      
    } #t
  
  } #i

```

## NIMBLE: HAPE data prep

```{r}

# Execute simulation function
sim <- simulateHistoriesHAPE(PSI.STATE, PSI.OBS, n, NOTSEEABLE = 3)

ch <- sim$ch
ch <- ch[1:500, ]

# Compute date of first capture
f <- idFirstCaptureHAPE(ch)

# Recode CH matrix: note, a 0 is not allowed!
# 1 = alive and in study are, 2 = recovered dead, 3 = not seen or recovered
rch <- ch  # Recoded CH
rch[rch == 0] <- 3



z_known_jgs <- idKnownStatesHAPE(rch, 3)

x <- rch
x[x==3] <- NA

z_init_jgs <- createZInitsHAPE(rch, f)
z_init_jgs[!is.na(x)] <- NA


```

## NIMBLE: testcode1

```{r}

testcode1 <- nimbleCode({
  

# -------------------------------------------------
# Parameters:
# s: true survival probability
# r: recovery probability
# p: detection probability
# -------------------------------------------------
# States (S):
# 1 alive in study area
# 2 recently dead (and recovered)
# 3 recently dead, but not recovered, or dead (absorbing)
# Observations (O):
# 1 seen alive
# 2 recovered dead
# 3 neither seen nor recovered
# -------------------------------------------------

# Priors and constraints
for (t in 1:(n.occasions-1)){
   s[t] ~ dbeta(1, 1)
   p[t] ~ dbeta(1, 1)
   r[t] ~ dbeta(1, 1)
}


# Define state-transition and observation matrices 	

# Define probabilities of state S(t+1) given S(t)
   
   for (t in f[i]:(n.occasions-1)) {
      ps[1,t,1] <- s[t]
      ps[1,t,2] <- (1-s[t]) * r[t]
      ps[1,t,3] <- (1-s[t]) * (1-r[t])
      ps[2,t,1] <- 0
      ps[2,t,2] <- 0
      ps[2,t,3] <- 1
      ps[3,t,1] <- 0
      ps[3,t,2] <- 0
      ps[3,t,3] <- 1

      # Define probabilities of O(t) given S(t)
      po[1,t,1] <- p[t]
      po[1,t,2] <- 0
      po[1,t,3] <- 1-p[t]
      po[2,t,1] <- 0
      po[2,t,2] <- 1
      po[2,t,3] <- 0
      po[3,t,1] <- 0
      po[3,t,2] <- 0 
      po[3,t,3] <- 1
      
      } #t
      
  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], t-1, 1:3])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], t-1, 1:3])
      
    } #t
   
  } #i
})
  

```

## NIMBLE: run testcode 1

```{r}


testdata <- list(y = rch, 
                  f = f, 
                  n.occasions = dim(rch)[2], 
                  nind = dim(rch)[1],
                  z = z_known_jgs)


testinits <- function(){list(s = rbeta(4, 1, 1), 
                         r = rbeta(4, 1, 1), 
                         p = rbeta(4, 1, 1),
                         z = z_init_jgs)}  


testmodel <- nimbleMCMC(code = testcode,
                        constants = testdata,
                        inits = testinits,
                        nchains = 2, 
                        niter = 40000,
                        monitors = c('s','p','r'),
                        summary = TRUE)


testmodel$summary

MCMCtrace(object = testmodel$samples,
          pdf = F,
          params = "p",
          ind = T)

```

## NIMBLE: testcode2

```{r}

testcode2 <- nimbleCode({
  
# Priors and constraints

for (t in 1:(n.occasions-1)){
   s[t] ~ dbeta(1, 1)
   p[t] ~ dbeta(1, 1)
}

for (t in 1:2){
   r[t] ~ dbeta(1, 1)
}



# Define state-transition and observation matrices 	

   # Define probabilities of state S(t+1) given S(t)
   
   for (t in 1:(n.occasions-1)) {
      
      ps[1,t,1] <- s[t]
      ps[2,t,1] <- 0
      ps[2,t,2] <- 0
      ps[2,t,3] <- 1
      ps[3,t,1] <- 0
      ps[3,t,2] <- 0
      ps[3,t,3] <- 1

      # Define probabilities of O(t) given S(t)

      po[1,t,1] <- p[t]
      po[1,t,2] <- 0
      po[1,t,3] <- 1-p[t] 
      po[2,t,1] <- 0
      po[2,t,2] <- 1
      po[2,t,3] <- 0
      po[3,t,1] <- 0
      po[3,t,2] <- 0
      po[3,t,3] <- 1
      
    } #t
      
    rfix <- 0
    
    for (t in 1:2) {
      
      ps[1,t,2] <- 1-s[t] * rfix
      ps[1,t,3] <- 1-s[t] * (1-rfix)
      
    }  
     
    for (t in 3:4) {
      
      ps[1,t,2] <- (1-s[t]) * r[t-2]
      ps[1,t,3] <- (1-s[t]) * (1-r[t-2])
      
    } 
  
  
  
  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], t-1, 1:3])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], t-1, 1:3])
      
    } #t
   
  } #i
})

```

## NIMBLE: testcode3

```{r}

testcode3 <- nimbleCode({
  
# Priors and constraints

for (t in 1:(n.occasions-1)){
   s[t] ~ dbeta(1, 1)
}

for (t in 1:2){
  p[t] ~ dbeta(1, 1)
  r[t] ~ dbeta(1, 3)
}

# Define state-transition and observation matrices 	

   # Define probabilities of state S(t+1) given S(t)
   
   for (t in 1:(n.occasions-1)) {
      
      ps[1,t,1] <- s[t]
      ps[2,t,1] <- 0
      ps[2,t,2] <- 0
      ps[2,t,3] <- 1
      ps[3,t,1] <- 0
      ps[3,t,2] <- 0
      ps[3,t,3] <- 1

      # Define probabilities of O(t) given S(t)

      po[1,t,2] <- 0
      po[2,t,1] <- 0
      po[2,t,2] <- 1
      po[2,t,3] <- 0
      po[3,t,1] <- 0
      po[3,t,2] <- 0
      po[3,t,3] <- 1
      
    } #t
      
    rfix <- 0
    
    for (t in 1:2) {
      
      ps[1,t,2] <- 1-s[t] * rfix
      ps[1,t,3] <- 1-s[t] * (1-rfix)
      
    }  
     
    for (t in 3:4) {
      
      ps[1,t,2] <- (1-s[t]) * r[t-2]
      ps[1,t,3] <- (1-s[t]) * (1-r[t-2])
      
    } 
  
    for (t in 2:3) {
      
      po[1,t,1] <- p[t-1]
      po[1,t,3] <- 1-p[t-1]
      
    }
    
    po[1,1,1] <- 1
    po[1,4,1] <- 1
    po[1,1,3] <- 0 
    po[1,4,3] <- 0 
  
  
  # Likelihood 
  for (i in 1:nind) {

   # Define latent state at first capture
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], t-1, 1:3])
      
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], t-1, 1:3])
      
    } #t
   
  } #i
    
  success <- s[1] * s[2] * s[3] * s[4]
    
})

```

## NIMBLE: run testcode3

```{r}

testdata <- list(y = rch,
                 f = f,
                 n.occasions = dim(rch)[2],
                 nind = dim(rch)[1],
                 z = z_known_jgs)


testinits <- function() {list(s = rbeta(4, 1, 1),
                              r = rbeta(2, 1, 3), 
                              p = rbeta(2, 1, 1),
                              z = z_init_jgs)}  


testmodel <- nimbleMCMC(code = testcode3,
                        constants = testdata,
                        inits = testinits,
                        nchains = 2, 
                        niter = 50000,
                        monitors = c("s", "p", "r", "success"),
                        summary = TRUE)


MCMCsummary(testmodel$samples, 
            #HPD = TRUE, 
            #hpd_prob = 0.8,
            round = 3)


MCMCtrace(object = testmodel$samples,
          pdf = F,
          params = "success",
          ind = T)


```

## NIMBLE: testcode4 group effects on survival

```{r}

testcode4 <- nimbleCode({
  
# Priors and constraints


# Survival priors by stage and group membership
  
for (g in 1:ngroup) { 
  
  for (t in 1:(n.occasions - 1)) {
  
    s[g,t] ~ dbeta(1, 1)
  
    }

}  
  

# Detection and recovery priors for two intervals 
# other intervals have constant values, defined below
  
for (t in 1:2) {
  
  p[t] ~ dbeta(1, 1)
  r[t] ~ dbeta(1, 3)
  
}

# Define state-transition and observation matrices 
  
for (i in 1:nind) {
  
   for (t in 1:(n.occasions-1)) {
      
      # Define probabilities of state S(t+1) given S(t)

      ps[1,i,t,1] <- s[group[i],t]
      ps[2,i,t,1] <- 0
      ps[2,i,t,2] <- 0
      ps[2,i,t,3] <- 1
      ps[3,i,t,1] <- 0
      ps[3,i,t,2] <- 0
      ps[3,i,t,3] <- 1

      # Define probabilities of O(t) given S(t)

      po[1,i,t,2] <- 0
      po[2,i,t,1] <- 0
      po[2,i,t,2] <- 1
      po[2,i,t,3] <- 0
      po[3,i,t,1] <- 0
      po[3,i,t,2] <- 0
      po[3,i,t,3] <- 1
      
      } 
      
    # fix recovery parameters
  
    rfix <- 0
    
    for (t in 1:2) {
      
      ps[1,i,t,2] <- 1-s[group[i],t] * rfix
      ps[1,i,t,3] <- 1-s[group[i],t] * (1-rfix)
      
      }  
     
    for (t in 3:4) {
      
      ps[1,i,t,2] <- (1-s[group[i],t]) * r[t-2]
      ps[1,i,t,3] <- (1-s[group[i],t]) * (1-r[t-2])
      
      } 
  
    # fix detection parameters
    
    for (t in 2:3) {
      
      po[1,i,t,1] <- p[t-1]
      po[1,i,t,3] <- 1-p[t-1]
      
      }
    
    po[1,i,1,1] <- 1
    po[1,i,4,1] <- 1
    po[1,i,1,3] <- 0 
    po[1,i,4,3] <- 0 

}
  
  # Likelihood 
    
  for (i in 1:nind) {

   # Define latent state at first capture
    
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
     
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1, 1:3])
      
      # Observation process: draw O(t) given S(t)
     
      y[i,t] ~ dcat(po[z[i,t], i, t-1, 1:3])
      
      } #t
   
    } #i
    
  
  for (g in 1:ngroup) {
    
    success[g] <- s[g,1] * s[g,2] * s[g,3] * s[g,4]
    
  }
  
})

```

## NIMBLE: run testcode4

```{r}

testdata <- list(y = rch,
                 z = z_known_jgs)


testconstants <- list(f = f,
                      n.occasions = dim(rch)[2],
                      nind = dim(rch)[1],
                      ngroup = 5,
                      group = sample(1:5, 500, replace = T))


testinits <- function() {list(r = rbeta(2, 1, 3), 
                              p = rbeta(2, 1, 1),
                              z = z_init_jgs)}  


testmodel <- nimbleMCMC(code = testcode4,
                        data = testdata,
                        constants = testconstants,
                        inits = testinits,
                        nchains = 2, 
                        niter = 50000,
                        monitors = c("s", "p", "r", "success"),
                        summary = TRUE)


MCMCsummary(testmodel$samples, 
            #HPD = TRUE, 
            #hpd_prob = 0.8,
            round = 3)


MCMCtrace(object = testmodel$samples,
          pdf = F,
          params = "s",
          ind = T)


```
## NIMBLE: testcode5 random effects on survival

```{r}

testcode5 <- nimbleCode({
  
# Priors and constraints


# Survival priors by stage and group membership
  
for (i in 1:nind) { 
  
  for (t in f[i]:(n.occasions - 1)) {
  
    logit(s[i,t]) <- s.mean[t] + s.re[group[i],t]

    }

}  
  
  
s.mean[1:5] ~ dbeta(1, 1)
  s.eps[t] <- dnorm(0, g.sd[t])
  g.sd[t] ~ dunif(0, 5)

# Detection and recovery priors for two intervals 
# other intervals have constant values, defined below
  
for (t in 1:2) {
  
  p[t] ~ dbeta(1, 1)
  r[t] ~ dbeta(1, 3)
  
}

# Define state-transition and observation matrices 
  
for (i in 1:nind) {
  
   for (t in 1:(n.occasions-1)) {
      
      # Define probabilities of state S(t+1) given S(t)

      ps[1,i,t,1] <- s[i,t]
      ps[2,i,t,1] <- 0
      ps[2,i,t,2] <- 0
      ps[2,i,t,3] <- 1
      ps[3,i,t,1] <- 0
      ps[3,i,t,2] <- 0
      ps[3,i,t,3] <- 1

      # Define probabilities of O(t) given S(t)

      po[1,i,t,2] <- 0
      po[2,i,t,1] <- 0
      po[2,i,t,2] <- 1
      po[2,i,t,3] <- 0
      po[3,i,t,1] <- 0
      po[3,i,t,2] <- 0
      po[3,i,t,3] <- 1
      
      } 
      
    # fix recovery parameters
  
    rfix <- 0
    
    for (t in 1:2) {
      
      ps[1,i,t,2] <- 1-s[i,t] * rfix
      ps[1,i,t,3] <- 1-s[i,t] * (1-rfix)
      
      }  
     
    for (t in 3:4) {
      
      ps[1,i,t,2] <- (1-s[i,t]) * r[t-2]
      ps[1,i,t,3] <- (1-s[i,t]) * (1-r[t-2])
      
      } 
  
    # fix detection parameters
    
    for (t in 2:3) {
      
      po[1,i,t,1] <- p[t-1]
      po[1,i,t,3] <- 1-p[t-1]
      
      }
    
    po[1,i,1,1] <- 1
    po[1,i,4,1] <- 1
    po[1,i,1,3] <- 0 
    po[1,i,4,3] <- 0 

}
  
  # Likelihood 
    
  for (i in 1:nind) {

   # Define latent state at first capture
    
   z[i,f[i]] <- y[i,f[i]]
   
   for (t in (f[i]+1):n.occasions) {
   
      # State process: draw S(t) given S(t-1)
     
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1, 1:3])
      
      # Observation process: draw O(t) given S(t)
     
      y[i,t] ~ dcat(po[z[i,t], i, t-1, 1:3])
      
      } #t
   
    } #i
    
  
  for (g in 1:ngroup) {
    
    success[g] <- s[g,1] * s[g,2] * s[g,3] * s[g,4]
    
  }
  
})

```

## NIMBLE: run testcode4

```{r}

testdata <- list(y = rch,
                 z = z_known_jgs)


testconstants <- list(f = f,
                      n.occasions = dim(rch)[2],
                      nind = dim(rch)[1],
                      ngroup = 5,
                      group = sample(1:5, 500, replace = T))


testinits <- function() {list(r = rbeta(2, 1, 3), 
                              p = rbeta(2, 1, 1),
                              z = z_init_jgs)}  


testmodel <- nimbleMCMC(code = testcode4,
                        data = testdata,
                        constants = testconstants,
                        inits = testinits,
                        nchains = 2, 
                        niter = 50000,
                        monitors = c("s", "p", "r", "success"),
                        summary = TRUE)


MCMCsummary(testmodel$samples, 
            #HPD = TRUE, 
            #hpd_prob = 0.8,
            round = 3)


MCMCtrace(object = testmodel$samples,
          pdf = F,
          params = "s",
          ind = T)


```


```{r}


  for (t in 1:2) {
  
  logit(p[t]) <- p.alpha[t] #+ p.beta[t] * survey[i]  
  logit(r[t]) <- r.alpha[t] #+ r.beta[t] * survey[i] 
  
}

  p.alpha ~ dnorm(0, 3)
  r.alpha ~ dnorm(0, 3)

  
```

